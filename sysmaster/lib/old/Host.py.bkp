#!/usr/bin/python
import os,sys,re,time
import pexpect
from Parsers import *
from IOS import *
from Trace import *
from Util import *
from VirExceptions import *
from Errors import syslogErrors

from Variables import *
from VgcProc import *

sys.stdout.flush()
U_NAME = "root"
PASSWD = "0011231"
#PASSWD = "$viri123"
sshn = "ssh -oStrictHostKeyChecking=no -oCheckHostIP=no -oUserKnownHostsFile=/dev/null"

# Example usage
##!/usr/bin/python
#from Host import Host

#h = Host("nand03")
#h.get_ipmi_ip_addr()
#h.if_file_exists('/dev/vgca2')

# This needs to be uncommented if exceptions dont work
class TIMEOUT(Exception):
   pass
class CommandError(Exception):
   pass
class InvalidValuePassed(Exception):
   pass
#class DeviceBusy(Exception):
#   pass


class Host:
   def __init__(self,name,logfile_object = sys.stdout,u_name = U_NAME,passwd = PASSWD):

        self.name           = name
        self.logfile        = logfile_object
        self.user           = u_name
        self.passwd         = passwd
        # Expected prompt
        #[root@sqa05 ~]#
        # redhat
        #self.expected_prompt = "\[\S+@\S+\s+~\]#\s"
        #self.expected_prompt = "\[\S+@\S+\s+\S*~?\]#\s"
        
	# Generic
        #self.expected_prompt = "sqa\d+:.*# |\[\S+@\S+\s+\S*~?\]#\s|\S+@\S+:~#\s |root@.*# "
        #self.expected_prompt = "(sqa|aries)(\d+)?:.*# |\[\S+@\S+\s+\S*~?\]#\s|\S+@\S+:~#\s |root@.*# "
        #self.expected_prompt = "(sqa|aries)(\d+)?:.*# |\[\S+@\S+\s+\S*~?\]#\s|\S+@\S+:~#\s |root@.*# |~ # "
        self.expected_prompt = "\[\S+@\S+\s+\S*~?\]#\s|\S+@\S+:~#\s |root@.*# |~ # "
        # ubuntu
	# 'root@lynx:~# '	
        #self.expected_prompt = "\[?\S+@\S+\s*~\]?#\s"
        #self.expected_prompt = "sqa11:~\s+#\s"
	
	# Lynx
	# sqa11:~ # 
	

        self.connection = None

   def logon(self):

        trace_info("Logging on to  machine '%s'"%self.name)
        try:
            self.connection = pexpect.spawn(sshn + " " + self.user + "@" + self.name,
                                            logfile = self.logfile)
            # if no passwd,linux prompt will be passed 
            rc = self.connection.expect([".*(p|P)assword",self.expected_prompt],100)
        except pexpect.EOF:
            trace_error("Unable to connect to '%s'"%self.name)
            #raise
            sys.exit(1)
        
        # if no passwd prompt found,return
        if rc == 1:
            return 1

        self.connection.sendline(PASSWD)
        try:
            self.connection.expect(self.expected_prompt,100)
        except pexpect.TIMEOUT:
            raise pexpect.TIMEOUT("Timeout occured to get prompt '%s' after putting password"%self.expected_prompt)
            
        return 1
   
   def ser_logon(self,term_srv,port):
         str = "telnet %s %s"%(term_srv,port)
         try:
            self.connection = pexpect.spawn(str,
                                            logfile = self.logfile)
            # if no passwd,linux prompt will be passed 
            rc = self.connection.expect(["login:"],100)
            self.connection.sendline(self.user)
            rc = self.connection.expect([".*(p|P)assword",self.expected_prompt],100)
            self.connection.sendline(PASSWD)
         except pexpect.EOF:
            trace_error("Unable to connect to '%s'"%self.name)
            sys.exit(1)
            
   def ifStatsRpmLoaded(self,str = " "):
       
       if not self.ifVgcRpmLoaded("stats"):
           trace_error("Stat rpm not loaded %s"%str)
           sys.exit(1)
       return 1
       
   def modprobe(self,module,options = " "):
       cmd = "modprobe %s "%module
       if options:
           cmd = cmd + options
       self.flashResLeft(cmd)
       return 1
   def rmmod(self,module):
       self.flashResLeft("rmmod %s"%module)
       return 1
       
   def getKernelNoRpm(self,kernel):
	   k = re.search("kernel-(.*)\.rpm",kernel)
	   return k.group(1)
   def getKernelNo86(self,kernel):
	   j = re.search("kernel-(.*)\.x86_64\.rpm",kernel)
	   return j.group(1)
   
   def upgradeSlesKernel(self,kernel):
	   
	   trace_info("Upgrading to kernel '%s'"%kernel)
	   
	   path = "http://pxe/sles-rpms/"
	   ver = self.cat_etc_issue()
	   if ver == "sles11sp1":
		   str = "sles11sp1/"
	   elif ver == "sles11sp2":
	   	   str = "sles11sp2/"
	   else:
		   trace_error("Unsupported sles kernel upgrade on ver '%s'"%ver)
		   sys.exit(1)
	   
	   
	       
	   path = path + str 
	   # get http path, common for redhat5 and 6
           kernelPath = path + kernel
           
	   
	   kernStrComp = get_sles_kernel_from_rpm(kernel)
	   
	   
	   if self.get_kernel_ver()   == kernStrComp:
               print "Found installed kernel  as same returning"
               return 2

           # try three times
	   for loop in range(1,3):
		   
	       cmd = "rpm -Uvh %s --oldpackage"%kernelPath
	       trace_info("Running cmd '%s'"%cmd)
	       o = self.run_command(cmd)
	   
	       rc = o['rc']
	       out = o['output']
	    
	       if rc == 0:
		   break
	       else:
                   # check if firmware string is found
		   found_firmware_str = 0
		   for l in out:
			   if re.search("is needed by",l):
				found_firmware_str = 1
				break
	           if found_firmware_str == 1:
			   
		       trace_info("Found string 'is needed' in output")
		       
                       kernelRpmBase = get_sles_base_from_rpm(kernel)
		       pathFw = path + kernelRpmBase
		       cmdfw = "rpm -ivh %s "%pathFw
				#print cmdfw 
				#sys.exit(1)
                       
		       self.flashResLeft(cmdfw)
		       
		       continue
		   else:
			   raise ViriError ("Failed to upgrade sles kernel %s"%kernel)
                           print "("
                           for l in out:
                               print l
                           print ")"
			   sys.exit(1)
	   #sys.exit(1)			
	   self.reboot()
	   
	   
	   
	   if self.get_kernel_ver()   == kernStrComp:
		   trace_info("Upgrade to kernel %s successful"%kernel)
		   return 1
	   trace_error("Upgrade to kernel unsuccessful successful, found '%s', expected '%s'"%(self.get_kernel_ver(),kernel))
	   sys.exit(1)
   
   def upgradeKernel(self,kernel):
	   
	   trace_info("Upgrading to kernel '%s'"%kernel)
	   
	   path = "http://pxe/redhat-rpms/"
	   ver = self.cat_etc_issue()
	   if ver == "redhat6":
		   str = "rhel6/"
	   elif ver == "redhat5":
		   str = "rhel5/"
           elif ver == "sles11sp1":
		   self.upgradeSlesKernel(kernel)
                   return 1
           elif ver == "sles11sp2":
		   self.upgradeSlesKernel(kernel)
                   return 1
	   else:
		   trace_error("Unsupported kernel upgrade on ver '%s'"%ver)
		   sys.exit(1)
	   
	   #kernel = "kernel-2.6.32-131.0.15.el6.x86_64.rpm"
           if re.search("src",kernel):
               print "ERR: string contains src in kernel %s"%kernel
               sys.exit(1)
	       
	   path = path + str 
	   # get http path, common for redhat5 and 6
           kernelPath = path + kernel
           
	   #print path
	   # kernel-2.6.32-131.2.1.el6.x86_64.rpm
	   #remove rpm and kernel from passed kernel
	   # to be used for redhat6 uname -r comparision
	   k = re.search("kernel-(.*)\.rpm",kernel)
	   kernStrRH6 = k.group(1)
	   
	   j = re.search("kernel-(.*).x86_64\.rpm",kernel)
	   kernStrNo86 = j.group(1)
	   
	   #kerel str to compare, rh5 has no x86 in uname -r
	   kernStrComp = kernStrRH6
	   if ver == "redhat5":
		  kernStrComp =  kernStrNo86
	   
	   
	   if self.get_kernel_ver()   == kernStrComp:
               print "Found installed kernel  as same returning"
               return 2

           # try three times
	   for loop in range(1,3):
		   
	       cmd = "rpm -Uvh %s --oldpackage"%kernelPath
	       trace_info("Running cmd '%s'"%cmd)
	       o = self.run_command(cmd)
	   
	       rc = o['rc']
	       out = o['output']
	    
	       if rc == 0:
		   break
	       else:
                   # check if firmware string is found
		   found_firmware_str = 0
		   for l in out:
			   if re.search("kernel-firmware",l):
				found_firmware_str = 1
				break
	           if found_firmware_str == 1:
			   
		       trace_info("Found string with kernel firmware in output")
		       fwRpmStr = "kernel-firmware-" + kernStrNo86 + ".noarch.rpm"
		       pathFw = path + fwRpmStr
		       cmdfw = "rpm -Uvh %s "%pathFw
				#print cmdfw 
				#sys.exit(1)
		       self.flashResLeft(cmdfw)
		       
		       continue
		   else:
			   trace_error("Failed to upgrade to kernel %s"%kernel)
                           print "("
                           for l in out:
                               print l
                           print ")"
			   sys.exit(1)
	   #sys.exit(1)			
	   self.reboot()
	   
	   
	   
	   if self.get_kernel_ver()   == kernStrComp:
		   trace_info("Upgrade to kernel %s successful"%kernel)
		   return 1
	   trace_error("Upgrade to kernel unsuccessful successful, found '%s', expected '%s'"%(self.get_kernel_ver(),kernel))
	   sys.exit(1)


   def run_command_no_rc(self,command,timeout = 600):
       
       print command
       #sys.exit(1)
       
       self.connection.sendline(command)
       self.connection.expect(self.expected_prompt,timeout)
       
       output = self.connection.before.strip()
       output_a = output.split("\r\n")
       
       output_a1 = [ i .rstrip() for i in output_a]
       print output_a1
       return output_a1
   
   def run_command(self,command,
                     timeout = 3600,
                     verbose = 0, 
                     exp_out_prompt = [],
                     verboseOutput = 0,
                     verboseTime = 0):
        """ Runs the command on host, return output as array and return code as 
            integer ,example 
            self.host.run_command(cmd,exp_out_prompt = ["Continue creating array","yes"])
        """
        if self.connection == None:
            self.logon()
        
        
	sTime = get_epoch_time()
        # if bg process
        if re.search(".*&$",command):
            self.connection.sendline(command)
            self.connection.expect(self.expected_prompt,timeout)
            return 1
            
        trace_info("Running command '%s'"%command)
        # add the return code with command
        command = command + ';echo $?'

        #trace_info("timeout for command '%s' is %i"%(command,timeout))

        self.connection.sendline(command)
        #self.connection.wait() #added by bandeep
        
        # it is array, expected prompt
        expected_prompt = [self.expected_prompt]
        #expected_prompt = "test"
        
        if exp_out_prompt:
            if len(exp_out_prompt) != 2:
                trace_error("Please pass exp_out_prompt with length 2, passed as")
                print exp_out_prompt
                sys.exit(1)
            expected_prompt.append(exp_out_prompt[0])
            
        for i in range(0,2):
            try:
                returnrc = self.connection.expect(expected_prompt,timeout)
            except pexpect.TIMEOUT:
                print "-" * 40
                raise pexpect.TIMEOUT ("ERROR: command '%s' timedout"%command)
                
            except pexpect.EOF:
                print "-" * 40
                trace_error("ERROR: command '%s' EOF pexpect happened"%command)
                
                print " "
                
                output = self.connection.before.strip()
                output_a = output.split("\r\n")
                printOutput(output_a)
                
                print " "
                raise
                
            
            except:
                print "-" * 40
                print "ERR: unkown exception occured in pexpect"
                raise 
            if returnrc == 0:
                break
            elif returnrc == 1:
                self.connection.sendline(exp_out_prompt[1])
                continue
                _
        output = self.connection.before.strip()
        output_a = output.split("\r\n")
       
        # remove the expected prompt  from the end
        output_a.pop()
        
        #output_a = output_a[1:] # remove command
   
        # get the return code
        rc = output_a.pop()

        try:
            rc = int(rc)
        except ValueError:
            
            printOutput(output_a)
            trace_error("Could not convert return code of command '%s' to integer"%command)
            trace_error("Expecting integer found '%s'"%rc)
            sys.exit(1)


        if verbose == 1: print "INFO: Found return code of command '%s' as '%i'" %(command,int(rc))
	eTime = get_epoch_time()
	tTaken = eTime - sTime
	if verboseTime: 
            trace_info("Time took to run command '%s' '%s' secs"%(command,tTaken))
	
        #print "rc = '%s'"%rc
        #print output
        #for l in output:
            #print "l = '%s'"%l
        # return output_str as raw output
        # return output as normalized which is more useful 
        out = {'output_str': output,
               'output'    : output_a,
	       'time'      : tTaken,
               'rc'        : rc}
        
        
        if verboseOutput: 
            trace_info("Output of command '%s'"%command) 
            output = out['output']
            printOutput(output)
        
        return out

   
   def flashResLeft(self,command,timeout = 3600):
       o = self.run_command(command,timeout = timeout)
       rc = o['rc']
       out = o['output']

       if rc != 0:
           err = "Couldn't run the command '%s', found return code as '%i'"%(command,rc)
           trace_error(err)

           print "details = ("
           for l in out:
               print l
           print ")"
           out.insert(0,err)
           raise CommandError(out)

       return o

   def run_command_verify_out(self,command,verify_regex = None,errors = [],timeout = 600,chkrc = 1):

        if chkrc == 1:
            o = self.flashResLeft(command,timeout = timeout)

        else:
            o = self.run_command(command,timeout = timeout)

        out = o['output']

        if not is_var_list(errors):
            trace_error("Please pass errors as list")
            sys.exit(1)

        if verify_regex:
            found_out = 0
            for l in out:

                if re.search(verify_regex,l):
                    print "INFO: Found '%s' output in command '%s'"%(verify_regex,command)
                    found_out = 1
            if found_out == 0:
                    print "ERR: Couldn't find '%s' output in command '%s'"%(verify_regex,command)
                    sys.exit(1)
        # this and above could be combined and written as a function
        
        for e in errors:
            for l in out:
                if re.search(e,l):
                    trace_error("Found error '%s' in command '%s'"%(e,command))
                    raise CommandError

        
        return o

   def run_command_single_output(self,cmd):
       
       o = self.flashResLeft(cmd)
       
       output = o['output']
       
       return output[1:]
   
   def isIORunning(self,devPart):
       befIO = int(self.cat_proc_diskstats(devPart,"total"))
       
       sleep_time(1,"waiting 1 sec")
       aftIO = int(self.cat_proc_diskstats(devPart,"total"))
       
       #print aftIO
       #sys.exit(1)
       
       diff = aftIO - befIO
       
       trace_info("Found before IO %i after IO %i diff %i"%(befIO,aftIO,diff))
       
       if diff <= 2:
           return False
       
       #if diff == 0:
           #return False
       return True
       
       
           
       
   
   def cat_proc_diskstats(self,devPart,type):
       devPart = rmDevice(devPart)
       cmd = "cat /proc/diskstats | grep %s"%devPart
       
       if type == "reads":
           cmd =  "%s | awk '{print $6}'"%cmd
       elif type == "writes":
           cmd =  "%s | awk '{print $10}'"%cmd
       elif type == "total":
           cmd =  "%s | awk '{print $6 + $10}'"%cmd
       else:
           raise InvalidValuePassed("Unkown Value %s"%type)
       
       
       return self.run_command_single_output(cmd)[0]
       
       
       
   def getCPUs(self):
       
       cmd = 'grep -w "processor" /proc/cpuinfo | tail -1'
       output = self.run_command_single_output(cmd)
       
       noCpus = parseSplit(output)['processor']
       
       #print noCpus
       #sys.exit(1)
       return noCpus
   
   def getCPUModel(self):
       
       cmd = 'grep -w "model name" /proc/cpuinfo | tail -1'
       output = self.run_command_single_output(cmd)
       
       cpuModel = parseSplit(output)['model name']
       
       return cpuModel
       
   def clear_dmesg(self):
       print "Clearing dmesg"
       self.flashResLeft("dmesg -c")
       return 1
   
   def clear_dmesg_syslogs(self):
	self.clear_dmesg()
	self.clear_syslogs()
	return 1   
   def clear_syslogs(self):
       print "Clearing syslogs"
       self.flashResLeft("echo \" \" > /var/log/messages")
       return 1
   def get_dmesg(self,chkForErrors = 1):
       o = self.flashResLeft("dmesg")
       print "Getting dmesg"

       out =  o['output']
       print "("
       for l in out:
           print l
       print ")"
       
       if chkForErrors:
	   self.chk_for_errors_dmesg_syslogs(out)
       return 1
   
   def chk_for_errors_dmesg_syslogs(self,output):
	   
	for l in output:
	   #print l
           for e in syslogErrors:
	       if re.search(e,l):
		   trace_error("Found error str '%s' in dmesg or syslog line '%s'"%(e,l))
		   sys.exit(1)
	return 1
       
   def print_syslogs(self,chkForErrors = 1):
       o = self.flashResLeft("cat /var/log/messages")
       print "Getting syslogs"

       out =  o['output']
       
       if chkForErrors:
	   self.chk_for_errors_dmesg_syslogs(out)
       
       print "("
       for l in out:
	   print l
       print ")"

       return 1
   
       
   def run_vgc_monitor(self,device):
        """ 
       {'/dev/vgcb': {}, 'temp': '41', 'err': 'Last config apply had failed/Config apply in progress !!!', 'state': 'GOOD', 'part': {'/dev/vgcb0': {'raid': 'disabled', 'ucap': '401', 'db': {'11': {'life': '98.66', 'cap': '32', 'state': '3 5 7               GOOD', 'rgrp': '1'}, '10': {'life': '98.66', 'cap': '32', 'state': '2 4 6               GOOD', 'rgrp': '0'}, '13': {'life': '98.66', 'cap': '32', 'state': '3 5 7               GOOD', 'rgrp': '1'}, '12': {'life': '98.66', 'cap': '32', 'state': '2 4 6               GOOD', 'rgrp': '0'}, '15': {'life': '98.66', 'cap': '32', 'state': '3 5 7               GOOD', 'rgrp': '1'}, '14': {'life': '98.66', 'cap': '32', 'state': '2 4 6               GOOD', 'rgrp': '0'}, '1': {'life': '98.66', 'cap': '32', 'state': '3 5 7               GOOD', 'rgrp': '1'}, '0': {'life': '98.66', 'cap': '32', 'state': '2 4 6               GOOD', 'rgrp': '0'},

        """

        command = "vgc-monitor -d %s"%device 
        out =  self.flashResLeft(command)
        o  = out['output']
        
        return parse_vgc_monitor(o)
   
   def verify_vgc_monitor_zion_output(self,device):
	parsed_out = self.run_vgc_monitor(device)
	
        ret = verify_vgc_monitor_zion(parsed_out)
        
        return ret
         
	
	
	
   def get_device_state(self,device):
       o = self.run_vgc_monitor(device)
       return o['state']
   def get_device_part_state(self,dev_p):
       dev = get_vgc_dev_from_part(dev_p)
       o = self.run_vgc_monitor(dev)
       return o['part'][dev_p]['state']

   def verify_device_state(self,dev,exp_state):
       found_state = self.get_device_state(dev)

       if found_state == exp_state:
           trace_success("Found state of device '%s' as '%s' expected '%s'"%(dev,found_state,exp_state))
           return 1
       trace_error("Found state of device '%s' as '%s' expected '%s'"%(dev,found_state,exp_state))
       sys.exit(1)
   # get the partition state /dev/vgca0
   def verify_device_part_state(self,dev_p,exp_state):
       found_state = self.get_device_part_state(dev_p)

       if found_state == exp_state:
           trace_success("Found state of device '%s' as '%s' expected '%s'"%(dev_p,found_state,exp_state))
           return 1
       trace_error("Found state of device '%s' as '%s' expected '%s'"%(dev_p,found_state,exp_state))
       sys.exit(1)

   # this should be verify 
   def get_vgc_mon_dev_part_status(self,dev_p,exp_state):
       dev = get_vgc_dev_from_part(dev_p)

       self.verify_device_part_state(dev_p,exp_state)
       o = self.run_vgc_monitor(dev)

       dev_state = o['state']
       if dev_state != exp_state:
           trace_error("Found device '%s' state as '%s',expected '%s'"%(dev,dev_state,exp_state)) 
           sys.exit(1)
       trace_info("Found device '%s' state as '%s',expected '%s'"%(dev,dev_state,exp_state)) 

       dbs  = o['part'][dev_p]['db']

       for db in dbs:
           db_st = dbs[db]['state']
           if db_st != exp_state:
                trace_error("Found dbrd '%s' state as '%s',expected '%s' for device '%s'"%(db,db_st,exp_state,dev_p)) 
                sys.exit(1)
           trace_info("Found dbrd '%s' state as '%s',expected '%s' for device '%s'"%(db,db_st,exp_state,dev_p)) 
       
       return 1

   def verify_card_good_state(self,dev_p):
       return self.get_vgc_mon_dev_part_status(dev_p,"GOOD")
   
   def get_card_part_main_attr(self,device):
       """ takes /dev/vgca0, returns {'sector': '512', 'card_info': 'VIR-M2-LP-2200-2A, 3072 GiB, Double decker', 'ucap': '2222', 'raid': 'enabled', 'mode': 'maxcapacity'}
       """
       check_if_vgc_part(device)

       #remove partition 0
       device_m = get_vgc_dev_from_part(device)
       det =  self.run_vgc_monitor(device_m)
       # all the parser from vgc-monitor has part for the attributes
       raid = det['part'][device]['raid']
       ucap = det['part'][device]['ucap']
       mode = det['part'][device]['mode']
       card_info = det['card_info']
       build = det['build']

       dict = {}
       dict['raid'] = raid
       dict['ucap'] = ucap
       dict['mode'] = mode
       dict['card_info'] = card_info
       dict['build'] = build 

       #get sector from vgc-config
       sector = self.vgc_config()[device]['sector']
       dict['sector'] = sector

       return dict

   def get_card_state(self,device,state_exp = "GOOD"):
        c = run_vgc_monitor(device)
        state = c[device]['state']

        if state != state_exp:
            return False
            

        part = c[device]['part']

   def get_bdev(self,device):
       cmd = "blockdev --getsize64 %s"%device
       out =  self.flashResLeft(cmd)
       o  = out['output']
       bsize =  o[1]

       try:
           bsize = int(bsize)
       except ValueError:
           trace_error("Couldn't find the bdev for device %s as integer, found '%s' instead"%(device,bsize))
           sys.exit(1)

       return bsize
        

    
   def get_ipmi_ip_addr(self):
        command = "ipmitool lan print  | grep \"IP Address\" | grep -v Source | awk -F \":\" '{print $2}'"
        out = self.flashResLeft(command)
        output = out['output']
        print output

   def if_file_exists(self,file_path):

       # --color option was given since is changing pexpect
       command = "ls --color=none " + file_path

       out = self.run_command(command)
       rc = out['rc']

       if rc == 0:
           return True

       return False
   
   def rmFileifExists(self,file_path):
       
       if self.if_file_exists(file_path):
            self.flashResLeft("rm -rf %s*"%file_path)
       return 1
   def createDirifNotExists(self,dir):
       
       if self.if_file_exists(dir):
            return 1
       self.mkdir(dir)
       return 2
       
       

   def is_service_running(self,service):
        command = "service %s status"
        out = self.run_command_check_rc(command)
        output = out['output']

        regex_not_running = "is not running|not loaded"
        regex_is_running = "is running|modules?\s+(are\s+)loaded"

        # variable to check if at least found one string that shows module ouput has module running
        # if not found then, the output is wrong
        found_mod_running = 0

        for line in output:
            if re.search(regex_not_running,line):
                return False
            elif re.search(regex_is_running,line):
                found_mod_running = 1
            else:
                continue

        if found_mod_running == 0:
            print "Could'nt determine if '%s' is running,couldn't find expected output '%s'"%(service,regex_is_running)
            sys.exit(1)

        return True
     
     #def if_file_exists(self,file_path):

   
   def create_fs(self,device,fs,options = None):
       """ Example Usage: 
       h = Host("sqa05")
       h.create_fs("/dev/vgca0","ext3"," -J size=400") 
       h.create_fs("/dev/vgca0","xfs") """

       #self.connection.setwinsize(400,400)

       #command = "mkfs." + fs + " " +  device
       expected_prompt = self.expected_prompt

       # expected prompt had to be changed
       # this is hack
       # ext3/4 filesys get stuck, seems like if the expected prompt is complicated
       # pexpect gets stuck
       self.expected_prompt ='~( |\])# '
       

       command = "mkfs.%s %s"%(fs,device)

       if options:
           command = command + " " +  options

       # xfs requires -f option
       if fs == "xfs":
           command = command + " -f" 
       self.flashResLeft(command)
       
       self.expected_prompt = expected_prompt 
       return 1

   def mount_fs(self,device,mnt_point):
       
       if not mnt_point.startswith("/"):
	       trace_error("Mount point '%s' doesnt starts with /"%mnt_point)
	       sys.exit(1) 
       command = "mount %s %s"%(device,mnt_point)
       self.flashResLeft(command)
       return 1
   
   def get_mount_details(self,device):
	"""get filesystem and mount point,device from mount command
	takes device as input """
        
	cmd = "mount | grep %s"%device
	
	o = self.flashResLeft(cmd)
	output = o['output']
	
	pOut = parseMountOutput(output)
	
	return pOut
   
   def mount_fs_all(self,device,mnt_point,filesys):
       self.mkdir(mnt_point,force = 1)
       self.create_fs(device,filesys)
       self.mount_fs(device,mnt_point)
       return 1
   
   def getDuMap(self,device):
       
       vproc = vgcProc(self)
       return vproc.getDuMap(device)

   def confVgcdConfMount(self,devPart,mntPnt,fs):
       #/dev/vgca0   /mnt  ext3    noauto,defaults        0 0
       str = "%s %s %s noauto,defaults        0 0"%(devPart,mntPnt,fs)
       cmd = "echo %s >> /etc/fstab"%str
       self.flashResLeft(cmd)
       self.mkdir(mntPnt)
       #MOUNT_POINTS=""
       #sed -i 's/MOUNT_POINTS=\"\"/MOUNT_POINTS=\"\/nand4\"/' /etc/sysconfig/vgcd.conf
       cmd = "sed -i 's/MOUNT_POINTS=\"\"/MOUNT_POINTS=\"\"/' /etc/sysconfig/vgcd.conf"
       self.flashResLeft(cmd)

       cmd = "sed -i 's/MOUNT_POINTS=\"\"/MOUNT_POINTS=\"\%s\"/' /etc/sysconfig/vgcd.conf"%mntPnt
       self.flashResLeft(cmd)
       return 1

   def umount_fs(self,device):
       command = "umount %s "%device
       self.flashResLeft(command)
       return 1

   def umount(self,device):
       try:
          self.umount_fs(device)
       except CommandError:
          trace_info("Seems like device %s is already unmounted"%device)
          pass

   def mount(self,device,mnt_point):
       try:
          self.mount_fs(device,mnt_point)
       except CommandError:
          trace_info("Seems like device %s is already mounted"%device)
          pass

   def get_md5sum(self,file):
       comm = "md5sum %s | awk '{print $1}'"%file
       o = self.flashResLeft(comm)
       md5sum = o['output']
       return md5sum[1]
   
   def create_file_dd_get_md5sum(self,filePath):
	   io = DD(self)
	   io.runIO(filePath)
	   md5sum = self.get_md5sum(filePath)
	   return md5sum
   # this should take care of ubuntu also 
   def ifVgcRpmLoaded(self,rpm):
       
       try:
          self.flashResLeft("rpm -qa | grep vgc | grep %s"%rpm)
       except:
           
          trace_error("rpm %s doesn't seem to be loaded"%rpm)
          sys.exit(1)
       trace_info("vgc rpm '%s' seem to be present"%rpm)
       return 1
       
   def stopVgcDriver(self):
       """ exits if fail to stop,returns 1 on success,returns 2 if
       driver are not installed, 3 if driver is not present already """
       trace_info("Stopping vgcd driver")
       o = self.run_command("service vgcd stop")
       rc = o['rc']
       out = o['output']

       errString = "ERROR"
       if isStringPresentArray(out[1:],errString):

                trace_error("Failed to stop Driver, found string %s"%errString)
                sys.exit(1)
           
       driverAlreadyUnloadedStr = "kernel modules are not loaded"
       if isStringPresentArray(out[1:],driverAlreadyUnloadedStr):
               trace_info("Seems like driver already unloaded")
	       
       driverNotInstalledStr = "unrecognized service"
       if isStringPresentArray(out[1:],driverNotInstalledStr):
               trace_info("Seems like driver not installed while unloading driver, found string '%s'"%driverNotInstalledStr)
	       return 2
       driverNotInstalledStrSlesSP2 = "no such service"
       if isStringPresentArray(out[1:],driverNotInstalledStrSlesSP2):
               trace_info("Seems like driver not installed while unloading driver, found string '%s'"%driverNotInstalledStr)
	       return 3
           
       return 1
       
       
   def startVgcDriver(self):
       
       trace_info("Starting vgcd driver")
       self.flashResLeft("service vgcd start")
       return 1
   
   def restartVgcDriver(self):
       
       trace_info("Starting vgcd driver")
       self.flashResLeft("service vgcd restart")
       return 1
       
   def rmVgcdDrivers(self):
	  
	   # for rpm only
	   
	rc = self.stopVgcDriver()
        
        # just check rc as 1, other return code already 
        if rc == 1:
                   trace_info("Removing drivers")
		   self.flashResLeft("rpm -qa | egrep \"vgc|vfstore\" | xargs rpm -ev")
        return rc
		   
	   
        
	   
	   
		   
   def create_file(self,file):
       #comm = "dd if=/dev/urandom of=%s bs=1G count=1"%file
       comm = "dd if=/dev/urandom of=%s bs=4K count=1000 oflag=direct"%file
       self.flashResLeft(comm)
       self.flashResLeft("sync")
       return 1
   def get_kernel_ver(self):
       return self.flashResLeft("uname -r")['output'][1]

   def cat_etc_issue(self):
       if not self.if_file_exists("/etc/issue"):       
           trace_error("/etc/issue doesn't exists")
           sys.exit(1)
       o = self.flashResLeft("cat /etc/issue")
       out = o['output']
       
       try:
          p = parse_cat_etc_issue(out)
       except:
	  trace_info("Cound'nt find the version from /etc/issue,Trying from kernel")
	  # this is hack and need to be re written
	  kernel = self.get_kernel_ver()
	  
	  if re.search("2\.6\.32",kernel):
		  trace_info("Seem like redhat6 kernel")
		  return "redhat6"
	  elif re.search("2\.6\.18",kernel):
		  trace_info("Seem like redhat5 kernel")
		  return "redhat5"
	  else:
		trace_error("Failed fo find linux flavor")
		sys.exit(1)

       return p


   def installBuild(self,build,stats = None,server = "cloudy.virident.info", toolsTest = 1,pathType = "packages",emc = 1,firmware = 0):
	
	
	"""h.installBuild("C4.46300")"""
	#kmod-vgc-2.6.32-131.0.10.el6.x86_64-3.0-46300.C4.x86_64.rpm
        #kmod-vgc-2.6.32-131.0.10.el6.x86_64-3.0-46300.C4.stats.x86_64.rpm
	# kmod-vgc-2.6.32-71.el6.x86_64-3.0-46300.C4.x86_64.rpm
        #kmod-vgc-2.6.18-8.el5-3.0-46300.C4.x86_64.rpm
        #vgc-2.6.32.12-0.7-default-kmp-default-3.0_2.6.32.59_0.3-46300.C4.x86_64.rpm

        #vgc-3.0.13-0.27-default-kmp-default-3.0_3.0.26_0.7-46300.C4.x86_64.rpm
	
	#print server
	#sys.exit(1)
	
        
	#pathType = "packages"
        
        # this is needed, incase 0 is passed as string
        # 
        try:
          emc = int(emc)
          firmware = int(firmware)
          toolsTest = int(toolsTest)
          stats = int(stats)
          
        except:
            print "ERR: Couln't convert some value to integer in install Build"
            raise
        
        if emc and stats:
            raise ViriValuePassedError("Both emc and stats are true, please remove one of them")
        
        print "-" * 80
        trace_info("Installing build '%s'"%build)
        print "-" * 80
        
        print "-"
	linux = self.cat_etc_issue()
	kernel = self.get_kernel_ver()
	
	httpPath = get_build_string(build,linux,pathType,server)
	
	trace_info("Found linux distro '%s'"%linux)
	
	
        #pathDriver = get_vgc_driver_path(build,linux,kernel, stats = stats)
	#pathUtil =  get_vgc_utils_path(build,linux)
	
	#print pathUtil
	#print pathDriver
	
	#sys.exit(1)
	
	
	#cmd = "rpm -ivh %s %s"%(pathDriver,pathUtil)
	
	prependstr = " "
	# Redhat 5 needs not deps for now
	if linux == "redhat6":
	    
	    try:
               m = re.search("2.6.32-(\d+).*el6.*",kernel)
	       minorVer = m.group(1)
	       
	       #print minorVer
	       if int(minorVer) >= 131:
		       
		    prependstr = "kmod-vgc-2.6.32-131.0.10.el6.x86_64-3.0-"
                    if emc:
                        prependstr = "kmod-vfstore-2.6.32-131.0.10.el6.x86_64-1.0.0.00.00-"
		      
	       elif int(minorVer) == 71:
		    prependstr = "kmod-vgc-2.6.32-71.el6.x86_64-3.0-"
                    
                    if emc:
                        prependstr = "kmod-vfstore-2.6.32-71.el6.x86_64-1.0.0.00.00-"
                        
	       else:
		    trace_error("Couldn't find the prepend string for redhat6 '%s'"%kernel)
		    sys.exit(1)
			
	    except:
		trace_error("could get the minor version for Redhat6 kernel '%s'"%kernel)
		sys.exit(1)
	       
	elif linux == "redhat5":
                prependstr = "kmod-vgc-2.6.18-8.el5-3.0-"
                
                if emc:
                        prependstr = "kmod-vfstore-2.6.18-8.el5-1.0.0.00.00-"
		#prependstr = "kmod-vgc-2.6.18-238.el5-3.0-"
	elif linux == "sles11sp1":
            
		prependstr = "vgc-2.6.32.12-0.7-default-kmp-3.0-"
                if emc:
                    #prependstr = "vfstore-2.6.32.12-0.7-default-kmp-default-1.0.0.00.00_2.6.32.59_0.3-"
                    prependstr = "vfstore-2.6.32.12-0.7-default-kmp-1.0.0.00.00-"
                    
	elif linux == "sles11sp2":
                 
	        #prependstr = "vgc-3.0.13-0.27-default-kmp-default-3.0_3.0.26_0.7-"
                # vgc-3.0.13-0.27-default-kmp-3.0-48832.C5.x86_64.rpm
                # To do
                prependstr = "vgc-3.0.13-0.27-default-kmp-3.0-"
                if emc:
                    # vfstore-3.0.13-0.27-default-kmp-1.0.0.00.00-48832.C5.x86_64.rpm
                    prependstr = "vfstore-3.0.13-0.27-default-kmp-1.0.0.00.00-"
                    
	else:
		trace_error("Couldn't find linux version %s"%linux)
		sys.exit(1)
	
	
	lastStr = ".x86_64.rpm"
	lastStrStats = ".stats" + lastStr
	
	revBuild = reverse_build(build)
	httpPathUtils = "vgc-utils-3.0-" + revBuild + lastStr
        
        if emc:
            httpPathUtils = "vfstore-utils-1.0.0.00.00-" + revBuild + lastStr
            
	httpPathTools = "vgc-tools-3.0-" + revBuild + lastStr
	httpPathTests = "vgc-tests-3.0-" + revBuild + lastStr
	
	httpPathUtils = httpPath + httpPathUtils
	httpPathTools = httpPath + httpPathTools
	httpPathTests = httpPath + httpPathTests

	if stats:
		lastStr = lastStrStats
	
	httpPathDrv = httpPath + prependstr + reverse_build(build) + lastStr
	
	cmd = "rpm -ivph %s %s"%(httpPathDrv,httpPathUtils)
	
	
	
	#if linux == "redhat5":
	#	cmd = cmd +  " --nodeps"
	
	#sys.exit(1)
	self.rmVgcdDrivers()
	
	#trace_info("Running command cmd '%s'"%cmd)
        trace_info("Installing drivers")
	self.flashResLeft(cmd)
        
        if firmware:
            fwPath,fwTar,fwDir = get_vgc_fw_path(build,linux,pathType = pathType,emc = emc)
            
            self.flashResLeft("wget %s"%fwPath)
            self.flashResLeft("tar -xvzf %s"%fwTar)
            #self.flashResLeft("cd %s"%fwDir)
            self.flashResLeft("%s/vgc-update.sh --auto"%fwDir,timeout = 3600)
            #self.flashResLeft("./vgc-update.sh --auto",timeout = 3600)
            #self.flashResLeft("cd")
            print "Power cycle the box"
            sys.exit(0)
	
	if toolsTest:
		cmd = "rpm -ivph %s %s --nodeps"%(httpPathTools,httpPathTests)
                trace_info("Installing tools and stats rpms")
		#trace_info("Running command cmd '%s'"%cmd)
		self.flashResLeft(cmd)
	
	
        
            
	self.startVgcDriver()
        
        self.flashResLeft("rpm -qa | grep vgc")
	self.flashResLeft("vgc-monitor")
        
        trace_success_dashed("Install seems successful")
	
	return 1
	
   def mkdir(self,dir,force =1 ):
       
       if force == 1:
	     try:
                self.flashResLeft("rm -rf %s"%dir)
             except CommandError:
                print "INFO: Seems like directory to remove doesn't exist"
                
	       
	       
       comm = "mkdir %s"%dir
       self.flashResLeft(comm)
       return 1

   def rmdir(self,dir):
       comm = "rm -rf %s"%dir
       try:
          self.flashResLeft(comm)
       except CommandError:
          print "INFO: Seems like directory to remove doesn't exist"
          sys.exit(1)
       return 1

   def scp(self,dest,userid,passwd):

       prompt_regex = "password"
       rc = self.connection.expect([prompt_regex],timeout = 60)
       self.connection.sendline(passwd)
       self.connection.expect(self.expected_prompt,140)

   def vgc_sec_er(self,device,option):
       if option != "purge" and option != "clear" and option != "verbose" and option != "default":
           print "ERR: Please pass option as purge /clear /default/verbose"
           sys.exit(1)
       #vgcSecErPath= "/usr/lib/virident/vgc-secure-erase"
       vgcSecErPath= "vgc-secure-erase"
       comm = "%s --%s %s"%(vgcSecErPath,option,device)
       trace_info("Running vgc secure erase command '%s'"%comm)
       if option == "default":
          comm = "%s %s"%(vgcSecErPath,device)
       self.connection.sendline(comm)
       rc = self.connection.expect(["Do you want to continue","Device or resource busy"])
       if rc == 1:
           err = "Found 'Device or resource busy' in command '%s'"%comm
           trace_error(err)
           raise DeviceBusy(err)
       self.connection.sendline("yes")
       self.connection.expect(self.expected_prompt,14000)
       output = self.connection.before.strip()
       output_a = output.split("\r\n")
       return output_a

   # run in the background
   def vgc_sec_er_bg(self,device_p,option):
       comm = "echo \"yes\" |vgc-secure-erase --%s %s&"%(option,device_p)

       self.run_command(comm)
       return 1


   def kill_proc(self,proc):
       self.flashResLeft("kill -9 `pidof %s`"%proc,timeout = 1000)
       return 1
   def ser_reload(self,ser = "vgcd"):
       self.flashResLeft("service %s reload"%ser,timeout = 1000)
   def ser_sts(self,sts,ser = "vgcd"):
       self.flashResLeft("service %s %s"%(ser,sts),timeout = 1000)
   def reset_card(self,device):
       cmd = "vgc-config -d  %s -r && service vgcd reload"%device
       self.flashResLeft(cmd,timeout = 1000)
       #self.ser_reload()
   def zion_reset_card(self,dev):
       chk_if_vdent_dev(dev)
       if if_vgc_dev_part(dev):
           trace_error("Device '%s' passed as partition, please without partition,e.g,/dev/vgca"%dev)
           raise VirDeviceError
       cmd = "vgc-config -d  %s -r -f"%dev
       self.flashResLeft(cmd,timeout = 1000)
       return 1

   def get_vgc_conf_valid_raid(self):
       return {'enabled': 1, 'disabled':1}
   def get_vgc_conf_valid_mode(self):
       return {'maxperformance': 1, 'maxcapacity':1}
   def get_vgc_conf_valid_sector(self):
       return {'512': 1, '4096':1}

   def chk_valid_vgc_conf_opt(self,opt,opt_param):

       if opt == "5":
           dict = self.get_vgc_conf_valid_raid()
           if not dict.has_key(opt_param):
               trace_error("Vaild option for opt '%s' is '%s', passed '%s'"%(opt,dict.keys(),opt_param))
               sys.exit(1)
       elif opt == "s":
           dict = self.get_vgc_conf_valid_sector()
           if not dict.has_key(opt_param):
               trace_error("Vaild option for opt '%s' is '%s', passed '%s'"%(opt,dict.keys(),opt_param))
               sys.exit(1)
       elif opt == "m":
           dict = self.get_vgc_conf_valid_mode()
           if not dict.has_key(opt_param):
               trace_error("Vaild option for opt '%s' is '%s', passed '%s'"%(opt,dict.keys(),opt_param))
               sys.exit(1)
       else:
           trace_error("Invalid option opt '%s'"%opt)
           sys.exit(1)
 


   def vgc_conf_v1(self,dev,opt,opt_param):

       self.chk_valid_vgc_conf_opt(opt,opt_param)
      
       cmd = "vgc-config -d %s -%s %s && service vgcd reload"%(dev,opt,opt_param)
       self.flashResLeft(cmd)
       return 1

   def reboot(self, power_cycle = False):
       
        # This is incase this method is called twice
        if self.connection == None:
            self.logon()
            
        if  power_cycle:
            trace_info("Power cycling host")
            rc = os.system("/home/bandeepd/python/cycle.py %s w"%self.name)
            if rc != 0:
                trace_error("Failed to powercycle %s"%self.name)
                sys.exit(1)
            self.connection.close()
            self.connection = None
            return 1

        trace_info("Rebooting host")
        #self.run_command("reboot")
	self.connection.sendline("reboot")
        
        for i in range(0,6):
           wait = 10
           
           sleep_time(wait, "after reboot") 
        
	   if not if_ping_successful(self.name):
		print "INFO:ping unsucessful, host seem to reboot"
                break
           else:
               trace_info("Ping still succesful,retrying..")
               continue
               
               
	else:
		raise ViriError( "ERR: ping seem to successful,reboot failed")
		sys.exit(1)

        # close the connection
        self.connection.close()
        self.connection = None

        is_hostup(self.name)

        return 1

   def power_cycle(self,wait = 10):
            trace_info("Power cycling host ,time between pw cycle '%s'"%wait)
            rc = os.system("/home/bandeepd/sqa/scripts/python/cycle2.py %s %s w"%(self.name,wait))
            if rc != 0:
                trace_error("Failed to powercycle %s"%self.name)
                sys.exit(1)
            self.connection.close()
            self.connection = None
            return 1

 

   def get_fs(self,device):
       # check_if_vgc_part(device)
       cmd = "file -s %s"%device
       o = self.run_command_verify_out(cmd,errors = ["No such file"])
       out = o['output']

       regex = ".*\s(\S+)\s+filesystem data"

       fs = ""
       for l in out:
           if re.search(regex,l):
               m = re.search(regex,l)
               fs = m.group(1)
       if not fs:
           trace_error("Couldn't get the file system on device '%s'"%device)
           trace_error("regex '%s' not found in the output of command "%regex)
           print_red("Output = '%s'"%out)
           sys.exit(1)
       # return in lower case letters
       return fs.lower()

   def create_and_verify_fs(self,device,fs,options = None):
       self.create_fs(device,fs,options)
       fs_found = self.get_fs(device)
       if fs == fs_found:
           trace_success("Created filesys '%s' found filesystem '%s' on device %s"%(fs,fs_found,device))
           return 1

       trace_error("Created fs %s found filesystem %s on device %s"%(fs,found_fs,device))
       sys.exit(1)

   def cp(self,src_file,dst_file):
       cmd = "cp %s %s"%(src_file,dst_file)
       self.flashResLeft(cmd)
       return 1
   def cp_dict(self,dst_file):
       self.cp("/usr/share/dict/linux.words",dst_file)
       return 1
   def get_part_usable_cap(self,device):
       cmd = "vgc-monitor -d %s | grep \"%s\""%(device,device)
       o =  self.flashResLeft(cmd)

       out =  o['output']

       part_usable_cap = {}

       for l in out:
       # if   /dev/vgcc0          2048 GiB            500 GB              enabled   GOOD
           if re.search("/dev/vgc[a-z]\d+.*",l):
               l_a = l.split()
               us_cap = l_a[3]
# more attrib can be added later
               part = l_a[0]
               part_usable_cap[part] = {} 
               part_usable_cap[part]['us_cap'] = us_cap 
       # return {'/dev/vgcc0': {'us_cap': '500'}}
       return part_usable_cap
   def get_part_mode(self,device):
       """get partition mode,takes input as /dev/vgca0"""
       cmd = "vgc-config --p %s  | grep -A1 \"Current Configuration\" | grep %s"%(device,device) 
       o =  self.flashResLeft(cmd)
       out = o['output']
       l_a = out[1].split()
       
       l_m = l_a[1]
       l_m_a = l_m.split("=")

       mod =  l_m_a[1]

       return mod
   
   def is_valid_raid_values(self,value):
	   dict = {'enabled':1,
	           'disabled':1,}
	   if dict.has_key(value):
		   return True
	   trace_error("Raid is not valid , found %s, expected values%s"%(value,dict.keys()))
	   sys.exit(1)
		   
   def parse_vgc_config(self,out):
       dict = {}

       for l in out:
           if re.search("/dev/vgc[a-z]\d+",l):
               a  = l.split()
               dev_p = a[0]
               dict[dev_p] = {}

               mode_str = a[1]
               mode_a   = mode_str.split("=")
               mode    = mode_a[1]

               sec_str = a[2]
               sec_a   = sec_str.split("=")
               sec     = sec_a[1]
               
               raid_str = a[3]
               raid_a   = raid_str.split("=")
               raid     = raid_a[1]
               dict[dev_p]['raid'] = raid
               dict[dev_p]['sector'] = sec 
               dict[dev_p]['mode'] =  mode 
	 
       return dict
	   
   def vgc_config(self):
       """get partition mode,takes input as /dev/vgca0"""
       o =  self.flashResLeft("vgc-config")
       out = o['output']
       
       dict = self.parse_vgc_config(out)
       return dict 

   def get_card_attr(self,device,attr):
       return self.run_vgc_monitor(device)[attr]

   def get_card_serial(self,device):
       """get card serial,takes input as /dev/vgca"""
       return self.get_card_attr(device,"serial")
   def get_card_part_attr(self,device,attr):
       check_if_vgc_part(device)
       # get /dev/vgca out of /dev/vgca0
       dev = get_device_part(device)
       """get card serial,takes input as /dev/vgca"""
       return self.run_vgc_monitor(dev)['part'][device][attr]

   def get_card_part_rw(self,dev_p):
       check_if_vgc_part(dev_p)
       dev = get_device_part(dev_p)
       vgcMon = self.run_vgc_monitor(dev)
       dict = {}
       read  = vgcMon['part'][dev_p]['read']
       write = vgcMon['part'][dev_p]['write']
       return (read,write) 

   def get_card_part_rw_life(self,dev_p):
       check_if_vgc_part(dev_p)
       dev = get_device_part(dev_p)
       vgcMon = self.run_vgc_monitor(dev)
       dict = {}
       read  = vgcMon['part'][dev_p]['read']
       write = vgcMon['part'][dev_p]['write']
       life = vgcMon['part'][dev_p]['life']
       return (read,write,life) 


   def get_card_info(self,device):
       """get card info,takes input as /dev/vgca"""
       cmd = "vgc-monitor -d %s | grep \"Card Info\""%device
       o =  self.flashResLeft(cmd)
       out = o['output'][1]
       out_a = out.split(":")

       return out_a[1].strip()

   def get_offset_0_pbn(self,drive):
       """takes a0 and map as inputs"""
       option = "map"
       cmd = "%s /proc/driver/virident/vgcdrive%s/%s | head -1"%(VGCPROC,drive,option)
       o =  self.flashResLeft(cmd)
       x = o['output'][1]
       x_a = x.split()
       return x_a[1]

   def configure_zion_card(self,device,raid,sector,mode,n = None):
       """ Usage example:
       
       """
       if if_vgc_dev(device) and not n:
           trace_error("Number of partition not passed device %s"%device) 
           sys.exit(1)
       if if_vgc_dev_part(device) and n:
           trace_error("Partition passed as %s but device passed  as partition '%s'"%(n,device))
           sys.exit(1)

       cmd = "vgc-config -s %s -5 %s -m %s -f"%(sector,raid,mode)

       # if /dev/vgca and /dev/vgca0 add -n 
       if if_vgc_dev(device):
           cmd = cmd + " -d %s -n %s"%(device,n)
       elif if_vgc_dev_part(device):
           check_if_vgc_part(device)
           cmd = cmd + " -p %s "%device
       else:
           trace_error("Please pass  vgc device not as '%s'"%device) 
           sys.exit(1) 
       time_s = int(time.time())
       trace_info("Running command '%s'"%cmd)
       o = self.flashResLeft(cmd)
       out = o['output']
       print "Found output ("
       for l in out:
           print l
       print ")"
       time_f = int(time.time())
       
       time_diff = time_f - time_s

       trace_info("Time took '%i' secs"%time_diff)

       return 1
       
   def configure_zion_card_latest(self,device,mode,n = None):
       """ Usage example:
       
       """
       if if_vgc_dev(device) and not n:
           trace_error("Number of partition not passed device %s"%device) 
           sys.exit(1)
       if if_vgc_dev_part(device) and n:
           trace_error("Partition passed as %s but device passed  as partition '%s'"%(n,device))
           sys.exit(1)

       cmd = "vgc-config -m %s -f"%mode

       # if /dev/vgca and /dev/vgca0 add -n 
       if if_vgc_dev(device):
           cmd = cmd + " -d %s -n %s"%(device,n)
       elif if_vgc_dev_part(device):
           check_if_vgc_part(device)
           cmd = cmd + " -p %s "%device
       else:
           trace_error("Please pass  vgc device not as '%s'"%device) 
           sys.exit(1) 
       time_s = int(time.time())
       trace_info("Running command '%s'"%cmd)
       o = self.flashResLeft(cmd)
       out = o['output']
       print "Found output ("
       for l in out:
           print l
       print ")"
       time_f = int(time.time())
       
       time_diff = time_f - time_s

       trace_info("Time took '%i' secs"%time_diff)

       return 1

   def get_host_device_ver(self,device):
       """takes /dev/vgcc0 or /dev/vgcc as input,print kernel, cat /etc/isue"""

       chk_if_vdent_dev(device)

       # if device is
       if if_vgc_dev_part(device):
           device = get_vgc_dev_from_part(device)
       build = self.run_vgc_monitor(device)['build']
       
       #build = self.get_card_part_main_attr(device)['build']
       kernel = self.get_kernel_ver()
       ver = self.cat_etc_issue()

       det = {}

       det['kernel'] = kernel 
       det['version'] = ver  # version of redhat
       det['build']   = build

       return det

   def if_file_has_string(self,string,file):

       if not self.if_file_exists(file):
           trace_error("File '%s' doesn't exist in the system"%file)
           sys.exit(1)
       o = self.run_command("grep \"%s\" %s"%(string,file))
       rc = o['rc']

       if rc == 0:
           trace_info("Found string '%s' in file '%s' ,grep rc = '%i'"%(string,file,rc))
           return True

       trace_info(" Didn't find string '%s' in file '%s' ,grep rc = '%i'"%(string,file,rc))
       return False

   def get_blockdev(self,dev_p):
       cmd = "blockdev --getsize64 " + dev_p
       o =  self.flashResLeft(cmd)
       blocks =  o['output'][1]
       try:
           int(blocks)
       except ValueError:
           trace_error("Found blocks as '%s' not as integer"%blocks)
           raise
       
       return blocks

   def wget_file(self,filePath):
      
      try:

          self.flashResLeft("wget %s"%filePath)
      except CommandError:
          print "ERR: wget to path '%s' failed"%filePath 
          sys.exit(1)
   
   def wgetReturnFileName(self,filePath):
       
       self.wget_file(filePath)
       
       # get file
       
       try:
          m = re.search(".*/(\S+)$",filePath)
          file = m.group(1)
       
       except:
          trace_error("Couln't get file name from wget file path '%s'"%filePath)
          raise
       return file
       
      
      
   
   def untar_and_unzip_file(self,file):
         """untars file and unzips file"""
         self.flashResLeft("tar -xvzf %s"%file)
         
         return 1
   def untar_and_unzip_file_cd(self,file,dir):
         
         self.untar_and_unzip_file(file)
         self.flashResLeft("cd %s"%dir)
         
         return 1
         
   def chmod(self,filePath,perm):
      
      try:

          self.flashResLeft("chmod %s %s"%(perm,filePath))
      except CommandError:
          print "ERR: Change of permission '%s' to file '%s' failed"%(perm,filePath) 
          sys.exit(1)
   
   
  
   def if_dpp_errors_drive_vgcopt(self,drvLetter,vgcprocOpt,partition = "0"):
           o = self.flashResLeft("%s /proc/driver/virident/vgcdrive%s%s/%s | grep DPP"
                        %(VGCPROC,drvLetter,partition,vgcprocOpt))

           out = o['output']
           out.pop(0) # remove command
           for l in out:
               print l
               l_a = l.split(":")
               #print l_a
               #sys.exit(1)
               try:
                  error = l_a[1]
               except IndexError:
                   printOutput(out)
                   raise IndexError ("Couldn't split string '%s'"%l_a)
               error = error.strip() # remove any white space
               if int(error) > 0:
                   str =  "Found dpp error '%s' for drive '%s' details '%s' vgcproc option as '%s'"%(error,drvLetter,l,vgcprocOpt)
                   print str
                   return True,str
                   #sys.exit(1)
               #print "error = '%s'"%error

           return False, " "

   def if_dpp_errors(self,dev_p):

        drvLetter,partition = get_device_letter_part(dev_p)

        for opt in ["bb_stats", "bdev"]:
            sts,str = self.if_dpp_errors_drive_vgcopt(drvLetter,"bb_stats",partition)
            if sts:
               trace_error(str)
               return sts,str

        return False, " "

   def chk_if_dpp_errors(self,dev_p):
        sts,str = self.if_dpp_errors(dev_p)

        if sts:
            return True
        return False
   
   
   


    








  


      


       


       
